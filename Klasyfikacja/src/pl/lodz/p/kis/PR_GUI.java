package pl.lodz.p.kis;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;

import Jama.Matrix;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * PR_GUI.java
 *
 * Created on 2013-03-05, 19:40:56
 */

/**
 * 
 * @author krzy
 */
public class PR_GUI extends javax.swing.JFrame {

	String InData; // dataset from a text file will be placed here
	int ClassCount = 0, FeatureCount = 0;
	double[][] F, FNew; // original feature matrix and transformed feature
						// matrix
	int[] ClassLabels, SampleCount;
	String[] ClassNames;

	private double[][] featuresA;
	private double[][] featuresB;
	private double[] averagesA;
	private double[] averagesB;
	private int[] selectedFeaturesIndices; //wybrane indeksy cech
	private int userFeatures; // liczba cech jaka wybral uzytkownik
	private Classifier classifier;
	
	/*
	 * ################################# UWAGA: DRUT
	 * #################################
	 */

	/** Creates new form PR_GUI */
	public PR_GUI() {
		initComponents();
		setSize(720, 410);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		rbg_F = new javax.swing.ButtonGroup();
		b_read = new javax.swing.JButton();
		jPanel2 = new javax.swing.JPanel();
		jLabel1 = new javax.swing.JLabel();
		l_dataset_name_l = new javax.swing.JLabel();
		jLabel3 = new javax.swing.JLabel();
		jLabel4 = new javax.swing.JLabel();
		l_dataset_name = new javax.swing.JLabel();
		l_nfeatures = new javax.swing.JLabel();
		jButton2 = new javax.swing.JButton();
		jPanel3 = new javax.swing.JPanel();
		jLabel5 = new javax.swing.JLabel();
		jLabel6 = new javax.swing.JLabel();
		selbox_nfeat = new javax.swing.JComboBox();
		jSeparator1 = new javax.swing.JSeparator();
		f_rb_extr = new javax.swing.JRadioButton();
		f_rb_sel = new javax.swing.JRadioButton();
		b_deriveFS = new javax.swing.JButton();
		jLabel10 = new javax.swing.JLabel();
		f_combo_criterion = new javax.swing.JComboBox();
		f_combo_PCA_LDA = new javax.swing.JComboBox();
		jLabel12 = new javax.swing.JLabel();
		tf_PCA_Energy = new javax.swing.JTextField();
		jLabel14 = new javax.swing.JLabel();
		jLabel15 = new javax.swing.JLabel();
		l_NewDim = new javax.swing.JLabel();
		jPanel1 = new javax.swing.JPanel();
		jPanel4 = new javax.swing.JPanel();
		jLabel8 = new javax.swing.JLabel();
		jLabel9 = new javax.swing.JLabel();
		jComboBox2 = new javax.swing.JComboBox();
		b_Train = new javax.swing.JButton();
		jButton4 = new javax.swing.JButton();
		jLabel16 = new javax.swing.JLabel();
		tf_TrainSetSize = new javax.swing.JTextField();
		jLabel17 = new javax.swing.JLabel();
		jPanel5 = new javax.swing.JPanel();
		jLabel2 = new javax.swing.JLabel();
		l_FLD_winner = new javax.swing.JLabel();
		jLabel13 = new javax.swing.JLabel();
		l_FLD_val = new javax.swing.JLabel();

		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
		getContentPane().setLayout(null);

		b_read.setText("Read dataset");
		b_read.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				b_readActionPerformed(evt);
			}
		});
		getContentPane().add(b_read);
		b_read.setBounds(20, 10, 130, 25);

		jPanel2.setBackground(new java.awt.Color(204, 255, 255));
		jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

		jLabel1.setFont(new java.awt.Font("Comic Sans MS", 0, 18)); // NOI18N
		jLabel1.setText("Dataset info");

		l_dataset_name_l.setText("Name:");

		jLabel3.setText("Classes:");

		jLabel4.setText("Features:");

		l_dataset_name.setText("...");

		l_nfeatures.setText("...");

		javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(
				jPanel2);
		jPanel2.setLayout(jPanel2Layout);
		jPanel2Layout
				.setHorizontalGroup(jPanel2Layout
						.createParallelGroup(
								javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(
								javax.swing.GroupLayout.Alignment.TRAILING,
								jPanel2Layout
										.createSequentialGroup()
										.addContainerGap()
										.addGroup(
												jPanel2Layout
														.createParallelGroup(
																javax.swing.GroupLayout.Alignment.LEADING)
														.addGroup(
																jPanel2Layout
																		.createSequentialGroup()
																		.addComponent(
																				l_dataset_name_l)
																		.addGap(18,
																				18,
																				18)
																		.addComponent(
																				l_dataset_name))
														.addComponent(jLabel1))
										.addGroup(
												jPanel2Layout
														.createParallelGroup(
																javax.swing.GroupLayout.Alignment.LEADING)
														.addGroup(
																jPanel2Layout
																		.createSequentialGroup()
																		.addGap(115,
																				115,
																				115)
																		.addComponent(
																				jLabel3))
														.addGroup(
																jPanel2Layout
																		.createSequentialGroup()
																		.addGap(94,
																				94,
																				94)
																		.addComponent(
																				jLabel4)
																		.addPreferredGap(
																				javax.swing.LayoutStyle.ComponentPlacement.RELATED)
																		.addComponent(
																				l_nfeatures)))
										.addGap(100, 100, 100)));
		jPanel2Layout
				.setVerticalGroup(jPanel2Layout
						.createParallelGroup(
								javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(
								jPanel2Layout
										.createSequentialGroup()
										.addGroup(
												jPanel2Layout
														.createParallelGroup(
																javax.swing.GroupLayout.Alignment.BASELINE)
														.addComponent(jLabel1)
														.addComponent(jLabel3))
										.addGap(10, 10, 10)
										.addGroup(
												jPanel2Layout
														.createParallelGroup(
																javax.swing.GroupLayout.Alignment.BASELINE)
														.addComponent(
																l_dataset_name_l)
														.addComponent(jLabel4)
														.addComponent(
																l_dataset_name)
														.addComponent(
																l_nfeatures))
										.addContainerGap(24, Short.MAX_VALUE)));

		getContentPane().add(jPanel2);
		jPanel2.setBounds(10, 50, 320, 80);

		jButton2.setText("Parse dataset");
		jButton2.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				jButton2ActionPerformed(evt);
			}
		});
		getContentPane().add(jButton2);
		jButton2.setBounds(190, 10, 130, 25);

		jPanel3.setBackground(new java.awt.Color(255, 255, 204));
		jPanel3.setBorder(javax.swing.BorderFactory.createEtchedBorder());
		jPanel3.setLayout(null);

		jLabel5.setFont(new java.awt.Font("Comic Sans MS", 0, 18)); // NOI18N
		jLabel5.setText("Feature space");
		jPanel3.add(jLabel5);
		jLabel5.setBounds(14, 2, 118, 26);

		jLabel6.setText("FS Dimension");
		jPanel3.add(jLabel6);
		jLabel6.setBounds(178, 9, 78, 16);

		selbox_nfeat.setModel(new javax.swing.DefaultComboBoxModel(
				new String[] { "1", "2", "3", "4", "5" }));
		selbox_nfeat.setEnabled(true);
		jPanel3.add(selbox_nfeat);
		selbox_nfeat.setBounds(268, 6, 34, 22);
		jPanel3.add(jSeparator1);
		jSeparator1.setBounds(14, 41, 290, 10);

		f_rb_extr.setBackground(new java.awt.Color(255, 255, 204));
		rbg_F.add(f_rb_extr);
		f_rb_extr.setText("Feature extraction");
		f_rb_extr.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				f_rb_extrActionPerformed(evt);
			}
		});
		jPanel3.add(f_rb_extr);
		f_rb_extr.setBounds(10, 110, 133, 25);

		f_rb_sel.setBackground(new java.awt.Color(255, 255, 204));
		rbg_F.add(f_rb_sel);
		f_rb_sel.setSelected(true);
		f_rb_sel.setText("Feature selection");
		f_rb_sel.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				f_rb_selActionPerformed(evt);
			}
		});
		jPanel3.add(f_rb_sel);
		f_rb_sel.setBounds(10, 60, 127, 25);

		b_deriveFS.setText("Derive Feature Space");
		b_deriveFS.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				b_deriveFSActionPerformed(evt);
			}
		});
		jPanel3.add(b_deriveFS);
		b_deriveFS.setBounds(10, 180, 292, 25);

		jLabel10.setText("Criterion");
		jPanel3.add(jLabel10);
		jLabel10.setBounds(200, 50, 49, 16);

		f_combo_criterion
				.setModel(new javax.swing.DefaultComboBoxModel(new String[] {
						"Fisher discriminant", "Classification error" }));
		f_combo_criterion.setEnabled(false);
		jPanel3.add(f_combo_criterion);
		f_combo_criterion.setBounds(160, 70, 140, 22);

		f_combo_PCA_LDA.setModel(new javax.swing.DefaultComboBoxModel(
				new String[] { "PCA", "LDA" }));
		f_combo_PCA_LDA.setEnabled(false);
		jPanel3.add(f_combo_PCA_LDA);
		f_combo_PCA_LDA.setBounds(190, 110, 70, 22);

		jLabel12.setText("Energy");
		jPanel3.add(jLabel12);
		jLabel12.setBounds(20, 150, 39, 16);

		tf_PCA_Energy.setText("80");
		jPanel3.add(tf_PCA_Energy);
		tf_PCA_Energy.setBounds(70, 150, 30, 22);

		jLabel14.setText("%");
		jPanel3.add(jLabel14);
		jLabel14.setBounds(110, 150, 20, 16);

		jLabel15.setText("New dimension:");
		jPanel3.add(jLabel15);
		jLabel15.setBounds(160, 150, 92, 16);

		l_NewDim.setText("...");
		jPanel3.add(l_NewDim);
		l_NewDim.setBounds(270, 150, 30, 16);

		getContentPane().add(jPanel3);
		jPanel3.setBounds(10, 140, 320, 220);

		jPanel1.setBackground(new java.awt.Color(255, 255, 255));
		jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

		javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(
				jPanel1);
		jPanel1.setLayout(jPanel1Layout);
		jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 156,
				Short.MAX_VALUE));
		jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 126,
				Short.MAX_VALUE));

		getContentPane().add(jPanel1);
		jPanel1.setBounds(530, 10, 160, 130);

		jPanel4.setBackground(new java.awt.Color(204, 255, 204));
		jPanel4.setBorder(javax.swing.BorderFactory.createEtchedBorder());
		jPanel4.setLayout(null);

		jLabel8.setFont(new java.awt.Font("Comic Sans MS", 0, 18)); // NOI18N
		jLabel8.setText("Classifier");
		jPanel4.add(jLabel8);
		jLabel8.setBounds(10, 0, 79, 26);

		jLabel9.setText("Method");
		jPanel4.add(jLabel9);
		jLabel9.setBounds(14, 44, 42, 16);

		jComboBox2.setModel(new javax.swing.DefaultComboBoxModel(new String[] {
				"Nearest neighbor (NN)", "Nearest Mean (NM)",
				"k-Nearest Neighbor (k-NN)", "k-Nearest Mean (k-NM)" }));
		jPanel4.add(jComboBox2);
		jComboBox2.setBounds(74, 41, 178, 22);

		b_Train.setText("Train");
		b_Train.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				b_TrainActionPerformed(evt);
			}
		});
		
		jButton4.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				b_ExecuteActionPerformed(evt);
			}
		});
		
		jPanel4.add(b_Train);
		b_Train.setBounds(40, 130, 98, 25);

		jButton4.setText("Execute");
		jPanel4.add(jButton4);
		jButton4.setBounds(210, 130, 96, 25);

		jLabel16.setText("Training part:");
		jPanel4.add(jLabel16);
		jLabel16.setBounds(20, 170, 80, 16);

		tf_TrainSetSize.setText("80");
		jPanel4.add(tf_TrainSetSize);
		tf_TrainSetSize.setBounds(110, 170, 20, 22);

		jLabel17.setText("%");
		jPanel4.add(jLabel17);
		jLabel17.setBounds(140, 170, 20, 16);

		getContentPane().add(jPanel4);
		jPanel4.setBounds(340, 150, 350, 210);

		jPanel5.setBorder(javax.swing.BorderFactory
				.createTitledBorder("Results"));
		jPanel5.setLayout(null);

		jLabel2.setText("FS Winner:");
		jPanel5.add(jLabel2);
		jLabel2.setBounds(10, 30, 70, 16);

		l_FLD_winner.setText("xxx");
		jPanel5.add(l_FLD_winner);
		l_FLD_winner.setBounds(100, 30, 18, 16);

		jLabel13.setText("FLD value: ");
		jPanel5.add(jLabel13);
		jLabel13.setBounds(10, 60, 70, 16);

		l_FLD_val.setText("vvv");
		jPanel5.add(l_FLD_val);
		l_FLD_val.setBounds(100, 60, 48, 16);

		getContentPane().add(jPanel5);
		jPanel5.setBounds(340, 10, 160, 130);

		pack();
	}// </editor-fold>//GEN-END:initComponents

	private void f_rb_selActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_f_rb_selActionPerformed
		f_combo_criterion.setEnabled(true);
		f_combo_PCA_LDA.setEnabled(false);
	}// GEN-LAST:event_f_rb_selActionPerformed

	private void f_rb_extrActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_f_rb_extrActionPerformed
		f_combo_criterion.setEnabled(false);
		f_combo_PCA_LDA.setEnabled(true);
	}// GEN-LAST:event_f_rb_extrActionPerformed

	private void b_readActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_b_readActionPerformed
		// reads in a text file; contents is placed into a variable of String
		// type
		InData = readDataSet();
	}// GEN-LAST:event_b_readActionPerformed

	private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jButton2ActionPerformed
		// Analyze text inputted from a file: determine class number and labels
		// and number
		// of features; build feature matrix: columns - samples, rows - features
		try {
			if (InData != null) {
				getDatasetParameters();
				l_nfeatures.setText(FeatureCount + "");
				fillFeatureMatrix();
			}
		} catch (Exception ex) {
			JOptionPane.showMessageDialog(this, ex.getMessage());
		}

	}// GEN-LAST:event_jButton2ActionPerformed

	private void b_deriveFSActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_b_deriveFSActionPerformed
		// derive optimal feature space
		if (F == null)
			return;
		if (f_rb_sel.isSelected()) {
			// the chosen strategy is feature selection
			int[] flags = new int[FeatureCount];
			selectFeatures(flags,
					Integer.parseInt((String) selbox_nfeat.getSelectedItem()));
		} else if (f_rb_extr.isSelected()) {
			double TotEnergy = Double.parseDouble(tf_PCA_Energy.getText()) / 100.0;
			// Target dimension (if k>0) or flag for energy-based dimension
			// (k=0)
			int k = 0;
			// double[][] FF = { {1,1}, {1,2}};
			// double[][] FF = { {-2,0,2}, {-1,0,1}};
			// F is an array of initial features, FNew is the resulting array
			double[][] FFNorm = centerAroundMean(F);
			Matrix Cov = computeCovarianceMatrix(FFNorm);
			Matrix TransformMat = extractFeatures(Cov, TotEnergy, k);
			FNew = projectSamples(new Matrix(FFNorm), TransformMat);
			// FNew is a matrix with samples projected to a new feature space
			l_NewDim.setText(FNew.length + "");
		}
	}// GEN-LAST:event_b_deriveFSActionPerformed

	private void b_TrainActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_b_TrainActionPerformed
		int selectedOption = jComboBox2.getSelectedIndex();
		
		switch(selectedOption) {
			case 0:
				classifier = new NNClassifier();
				break;
			case 1:
				classifier = new NMClassifier();
				break;
			case 2:
				classifier = new KNNClassifier();
				break;
			case 3:
				classifier = new KNMClassifier();
				break;
		 }
		
	}// GEN-LAST:event_b_TrainActionPerformed

	private void b_ExecuteActionPerformed(java.awt.event.ActionEvent evt) {
		if (classifier != null)
			classifier.execute();
	}
	
	/**
	 * @param args
	 *            the command line arguments
	 */
	public static void main(String args[]) {
		java.awt.EventQueue.invokeLater(new Runnable() {
			public void run() {
				new PR_GUI().setVisible(true);
			}
		});
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JButton b_Train;
	private javax.swing.JButton b_deriveFS;
	private javax.swing.JButton b_read;
	private javax.swing.JComboBox f_combo_PCA_LDA;
	private javax.swing.JComboBox f_combo_criterion;
	private javax.swing.JRadioButton f_rb_extr;
	private javax.swing.JRadioButton f_rb_sel;
	private javax.swing.JButton jButton2;
	private javax.swing.JButton jButton4;
	private javax.swing.JComboBox jComboBox2;
	private javax.swing.JLabel jLabel1;
	private javax.swing.JLabel jLabel10;
	private javax.swing.JLabel jLabel12;
	private javax.swing.JLabel jLabel13;
	private javax.swing.JLabel jLabel14;
	private javax.swing.JLabel jLabel15;
	private javax.swing.JLabel jLabel16;
	private javax.swing.JLabel jLabel17;
	private javax.swing.JLabel jLabel2;
	private javax.swing.JLabel jLabel3;
	private javax.swing.JLabel jLabel4;
	private javax.swing.JLabel jLabel5;
	private javax.swing.JLabel jLabel6;
	private javax.swing.JLabel jLabel8;
	private javax.swing.JLabel jLabel9;
	private javax.swing.JPanel jPanel1;
	private javax.swing.JPanel jPanel2;
	private javax.swing.JPanel jPanel3;
	private javax.swing.JPanel jPanel4;
	private javax.swing.JPanel jPanel5;
	private javax.swing.JSeparator jSeparator1;
	private javax.swing.JLabel l_FLD_val;
	private javax.swing.JLabel l_FLD_winner;
	private javax.swing.JLabel l_NewDim;
	private javax.swing.JLabel l_dataset_name;
	private javax.swing.JLabel l_dataset_name_l;
	private javax.swing.JLabel l_nfeatures;
	private javax.swing.ButtonGroup rbg_F;
	private javax.swing.JComboBox selbox_nfeat;
	private javax.swing.JTextField tf_PCA_Energy;
	private javax.swing.JTextField tf_TrainSetSize;

	// End of variables declaration//GEN-END:variables

	/*
	 * ################################# UWAGA: KONIEC DRUTU!
	 * #################################
	 */

	private String readDataSet() {

		String s_tmp, s_out = "";
		JFileChooser jfc = new JFileChooser();
		jfc.setCurrentDirectory(new File("./"));
		FileNameExtensionFilter filter = new FileNameExtensionFilter(
				"Datasets - plain text files", "txt");
		jfc.setFileFilter(filter);
		if (jfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
			try {
				BufferedReader br = new BufferedReader(new FileReader(
						jfc.getSelectedFile()));
				while ((s_tmp = br.readLine()) != null)
					s_out += s_tmp + '$';
				br.close();
				l_dataset_name.setText(jfc.getSelectedFile().getName());
			} catch (Exception e) {
			}
		}
		return s_out;
	}

	private void getDatasetParameters() throws Exception {
		// based on data stored in InData determine: class count and names,
		// number of samples
		// and number of features; set the corresponding variables
		String stmp = InData, saux = "";
		// analyze the first line and get feature count: assume that number of
		// features
		// equals number of commas
		saux = InData.substring(InData.indexOf(',') + 1, InData.indexOf('$'));
		if (saux.length() == 0)
			throw new Exception("The first line is empty");
		// saux stores the first line beginning from the first comma
		int count = 0;
		while (saux.indexOf(',') > 0) {
			saux = saux.substring(saux.indexOf(',') + 1);
			count++;
		}
		FeatureCount = count + 1; // the first parameter
		// Determine number of classes, class names and number of samples per
		// class
		boolean New;
		int index = -1;
		List<String> NameList = new ArrayList<String>();
		List<Integer> CountList = new ArrayList<Integer>();
		List<Integer> LabelList = new ArrayList<Integer>();
		while (stmp.length() > 1) {
			saux = stmp.substring(0, stmp.indexOf(' '));
			New = true;
			index++; // new class index
			for (int i = 0; i < NameList.size(); i++)
				if (saux.equals(NameList.get(i))) {
					New = false;
					index = i; // class index
				}
			if (New) {
				NameList.add(saux);
				CountList.add(0);
			} else {
				CountList.set(index, CountList.get(index).intValue() + 1);
			}
			LabelList.add(index); // class index for current row
			stmp = stmp.substring(stmp.indexOf('$') + 1);
		}
		// based on results of the above analysis, create variables
		ClassNames = new String[NameList.size()];
		for (int i = 0; i < ClassNames.length; i++)
			ClassNames[i] = NameList.get(i);
		SampleCount = new int[CountList.size()];
		for (int i = 0; i < SampleCount.length; i++)
			SampleCount[i] = CountList.get(i).intValue() + 1;
		ClassLabels = new int[LabelList.size()];
		for (int i = 0; i < ClassLabels.length; i++)
			ClassLabels[i] = LabelList.get(i).intValue();
	}

	private void fillFeatureMatrix() throws Exception {
		// having determined array size and class labels, fills in the feature
		// matrix
		int n = 0;
		String saux, stmp = InData;
		for (int i = 0; i < SampleCount.length; i++)
			n += SampleCount[i];
		if (n <= 0)
			throw new Exception("no samples found");
		F = new double[FeatureCount][n]; // samples are placed column-wise
		for (int j = 0; j < n; j++) {
			saux = stmp.substring(0, stmp.indexOf('$'));
			saux = saux.substring(stmp.indexOf(',') + 1);
			for (int i = 0; i < FeatureCount - 1; i++) {
				F[i][j] = Double.parseDouble(saux.substring(0,
						saux.indexOf(',')));
				saux = saux.substring(saux.indexOf(',') + 1);
			}
			F[FeatureCount - 1][j] = Double.parseDouble(saux);
			stmp = stmp.substring(stmp.indexOf('$') + 1);
		}
		int cc = 1;
	}

	private void selectFeatures(int[] flags, int d) {
		featuresA = extractFeaturesMatrixForOneClass(F, 0);
		featuresB = extractFeaturesMatrixForOneClass(F, 1);
		averagesA = extractAveragesForOneClass(computeAveragesForAllFeatures(),
				0);
		averagesB = extractAveragesForOneClass(computeAveragesForAllFeatures(),
				1);

		System.out.println(Arrays.toString(featuresA[0]));
		userFeatures = d;

		if (d == 1) {
			double FLD = 0, tmp;
			int max_ind = -1;
			for (int i = 0; i < FeatureCount; i++) {
				if ((tmp = computeFisherLD(F[i])) > FLD) {
					FLD = tmp;
					max_ind = i;
				}
			}
			l_FLD_winner.setText(max_ind + "");
			l_FLD_val.setText(FLD + "");
		} else {
			//this.computeFisherLD(d);
			this.computeSfs(d);
		}
	}

	private double computeFisherLD(double[] vec) {
		// 1D, 2-classes
		double mA = 0, mB = 0, sA = 0, sB = 0;
		for (int i = 0; i < vec.length; i++) {
			if (ClassLabels[i] == 0) {
				mA += vec[i];
				sA += vec[i] * vec[i];
			} else {
				mB += vec[i];
				sB += vec[i] * vec[i];
			}
		}
		mA /= SampleCount[0];
		mB /= SampleCount[1];
		sA = sA / SampleCount[0] - mA * mA;
		sB = sB / SampleCount[1] - mB * mB;
		return Math.abs(mA - mB) / (Math.sqrt(sA) + Math.sqrt(sB));
	}

	/**
	 * Metoda liczy srednia wartosc danej cechy ze wszystkich obiektow. Zwraca
	 * wektor zawierajacy srednie wartosci cech dla dwoch klas.
	 */
	private double[] computeFeatureAverages(double[] vector) {
		double sumA, sumB;
		double counterA, counterB;
		sumA = sumB = counterA = counterB = 0;

		for (int i = 0; i < vector.length; i++) {
			if (ClassLabels[i] == 0) {
				sumA += vector[i];
				counterA++;
			} else {
				sumB += vector[i];
				counterB++;
			}
		}

		return new double[] { sumA / counterA, sumB / counterB };
	}

	/**
	 * Metoda zwraca macierz zawierajaca w usrednione wartosci wszystkich cech
	 * dla wszystkich klas. Wymiar macierzy iloss_cech x ilosc_klas
	 */
	private double[][] computeAveragesForAllFeatures() {
		double[][] result = new double[FeatureCount][];
		for (int i = 0; i < FeatureCount; i++) {
			result[i] = this.computeFeatureAverages(F[i]);
		}
		return result;
	}

	/**
	 * Metoda zwraca macierz zawierajaca powielone usrednione wartosci
	 * wszystkich cech dla jednej klasy. Macierz jest wykorzystywana do
	 * u³atwienia obliczeñ w rozrzucie.
	 */
	private Matrix cloneAverages(double[] avgVector, int numberOfCopies) {
		double[][] result = new double[numberOfCopies][];
		for (int i = 0; i < numberOfCopies; i++) {
			result[i] = Arrays.copyOf(avgVector, avgVector.length);
		}
		if (result.length != 0)
			return new Matrix(result).transpose();
		else return new Matrix(new double[0][0]);
	}

	/**
	 * Metoda liczy rozrzut wewnatrzklasowy dla zadanych cech.
	 */
	private Matrix computeClassSpread(double[][] features, double[] avgVector) {
		Matrix featuresMatrix = new Matrix(features);
		Matrix averagesMatrix = this.cloneAverages(avgVector,
				features[0].length);
		Matrix differenceMatrix = featuresMatrix.minus(averagesMatrix);
		return differenceMatrix.times(differenceMatrix.transpose());
	}

	/**
	 * Tworzy wektor skladajacy sie ze srednich dla jednej klasy.
	 */
	private double[] extractAveragesForOneClass(double[][] averages,
			int classIndex) {
		double[] averageVector = new double[FeatureCount];
		for (int i = 0; i < FeatureCount; i++)
			averageVector[i] = averages[i][classIndex];
		return averageVector;
	}

	/**
	 * Konwertuje liste do wektora
	 */
	private double[] convertToVectorOfDoubles(List<Double> input) {
		double[] result = new double[input.size()];

		for (int i = 0; i < input.size(); i++) {
			result[i] = input.get(i);
		}

		return result;
	}

	/**
	 * Zwraca macierz wszystkich cech dla wybranej klasy
	 */
	private double[][] extractFeaturesMatrixForOneClass(double[][] features,
			int classIndex) {
		double[][] result = new double[FeatureCount][];

		for (int i = 0; i < FeatureCount; i++) {
			List<Double> tmpFeatures = new ArrayList<Double>();
			for (int j = 0; j < features[i].length; j++) {
				if (ClassLabels[j] == classIndex) {
					tmpFeatures.add(features[i][j]);
				}
			}
			result[i] = this.convertToVectorOfDoubles(tmpFeatures);
		}
		return result;
	}

	/**
	 * Liczy dlugosc wektora
	 */
	private double computeVectorLength(double[] v) {
		double sum = 0.0;
		for (int i = 0; i < v.length; i++)
			sum += v[i] * v[i];
		return Math.sqrt(sum);
	}

	/**
	 * Odejmuje wektory
	 */
	private double[] subtractVectors(double[] a, double[] b) {
		double[] result = new double[a.length];
		for (int i = 0; i < a.length; i++) {
			result[i] = a[i] - b[i];
		}
		return result;
	}
	
	private double[] sumVectors(double[] a, double[] b) {
		double[] result = new double[a.length];
		for (int i = 0; i < a.length; i++){
			result[i] = a[i] + b[i];
		}
		return result;
	}

	/**
	 * Liczy wspolczynnik Fishera dla n cech.
	 */
	private double computeFisherFactor(double[] mA, double[] mB, double[][] a,
			double[][] b) {
		Matrix classSpreadA = computeClassSpread(a, mA);
		Matrix classSpreadB = computeClassSpread(b, mB);
		double[] differenceVector = subtractVectors(mA, mB);
		double vectorLength = computeVectorLength(differenceVector);

		return vectorLength / (classSpreadA.det() + classSpreadB.det());
	}

	/**
	 * Znajduje najlszepsze cechy wykorzystujac metode SFS.
	 * 
	 * @param numberOfFeatures
	 */
	private void computeSfs(int numberOfFeatures) {
		double methodStartTime = System.currentTimeMillis();
		System.out.println("[SFS - start]");

		double[] averagesA = extractAveragesForOneClass(
				computeAveragesForAllFeatures(), 0);
		double[] averagesB = extractAveragesForOneClass(
				computeAveragesForAllFeatures(), 1);

		Set<Integer> allFeaturesIndices = new HashSet<>();
		for (int i = 0; i < averagesA.length - 1; i++)
			allFeaturesIndices.add(i);

		double maxFisherFactor = 0.0;
		double currentFisherFactor = 0.0;
		int[] currentIndices = {};

		List<int[]> generatedIndices = ForwardSelector.generate(currentIndices,
				allFeaturesIndices);

		for (int i = 1; i <= numberOfFeatures; i++) {
			double[] selectedAveragesA = new double[i];
			double[] selectedAveragesB = new double[i];
			double[][] selectedFeaturesA = new double[i][];
			double[][] selectedFeaturesB = new double[i][];

			for (int[] indices : generatedIndices) {
				for (int j = 0; j < indices.length; j++) {
					selectedFeaturesA[j] = featuresA[indices[j]];
					selectedFeaturesB[j] = featuresB[indices[j]];
					selectedAveragesA[j] = averagesA[indices[j]];
					selectedAveragesB[j] = averagesB[indices[j]];
				}

				currentFisherFactor = computeFisherFactor(selectedAveragesA,
						selectedAveragesB, selectedFeaturesA, selectedFeaturesB);

				if (maxFisherFactor < currentFisherFactor) {
					maxFisherFactor = currentFisherFactor;
					currentIndices = indices;
				}
			}

			for (int index : currentIndices)
				allFeaturesIndices.remove(index);

			generatedIndices = ForwardSelector.generate(currentIndices,
					allFeaturesIndices);
		}

		selectedFeaturesIndices = currentIndices;
		System.out.println(Arrays.toString(currentIndices));
		System.out.println(maxFisherFactor);
		double methodStopTime = System.currentTimeMillis();
		System.out.println("[SFS - Stop] Execution time: "
				+ (methodStopTime - methodStartTime) + " miliseconds \n");
	}

	/**
	 * Liczy wspó³czynnik fishera klasyczn¹ metod¹.
	 * 
	 * @param numberOfFeatures
	 *            iloœæ wybranych cech.
	 */
	private void computeFisherLD(int numberOfFeatures) {
		double methodStartTime = System.currentTimeMillis();
		System.out.println("[Classic - Start]");

		double[] selectedAveragesA = new double[numberOfFeatures];
		double[] selectedAveragesB = new double[numberOfFeatures];

		double[][] selectedFeaturesA = new double[numberOfFeatures][];
		double[][] selectedFeaturesB = new double[numberOfFeatures][];

		List<int[]> combinations = Combinations.combinationsWithoutRepetitions(
				averagesA.length - 1, numberOfFeatures);
		int[] theBestFeatures = new int[numberOfFeatures];

		int index = 0;
		double maxFisherFactor = 0.0;
		double currentFisherFactor = 0.0;

		for (int[] c : combinations) {
			for (int i = 0; i < c.length; i++) {
				selectedFeaturesA[i] = featuresA[c[i]];
				selectedFeaturesB[i] = featuresB[c[i]];
				selectedAveragesA[index] = averagesA[c[i]];
				selectedAveragesB[index] = averagesB[c[i]];
				index += 1;
			}

			currentFisherFactor = computeFisherFactor(selectedAveragesA,
					selectedAveragesB, selectedFeaturesA, selectedFeaturesB);

			if (maxFisherFactor < currentFisherFactor) {
				maxFisherFactor = currentFisherFactor;
				theBestFeatures = c;
			}

			index = 0;
		}
		selectedFeaturesIndices = theBestFeatures;
		System.out.println(Arrays.toString(theBestFeatures));
		System.out.println(maxFisherFactor);
		double methodStopTime = System.currentTimeMillis();
		System.out.println("[Classic - Stop ] Execution time: "
				+ (methodStopTime - methodStartTime) + " miliseconds \n");

	}

	private Matrix extractFeatures(Matrix C, double Ek, int k) {

		Matrix evecs, evals;
		// compute eigenvalues and eigenvectors
		evecs = C.eig().getV();
		evals = C.eig().getD();

		// PM: projection matrix that will hold a set dominant eigenvectors
		Matrix PM;
		if (k > 0) {
			// preset dimension of new feature space
			// PM = new double[evecs.getRowDimension()][k];
			PM = evecs.getMatrix(0, evecs.getRowDimension() - 1,
					evecs.getColumnDimension() - k,
					evecs.getColumnDimension() - 1);
		} else {
			// dimension will be determined based on scatter energy
			double TotEVal = evals.trace(); // total energy
			double EAccum = 0;
			int m = evals.getColumnDimension() - 1;
			while (EAccum < Ek * TotEVal) {
				EAccum += evals.get(m, m);
				m--;
			}
			PM = evecs.getMatrix(0, evecs.getRowDimension() - 1, m + 1,
					evecs.getColumnDimension() - 1);
		}

		/*
		 * System.out.println("Eigenvectors"); for(int i=0; i<r; i++){ for(int
		 * j=0; j<c; j++){ System.out.print(evecs[i][j]+" "); }
		 * System.out.println(); } System.out.println("Eigenvalues"); for(int
		 * i=0; i<r; i++){ for(int j=0; j<c; j++){
		 * System.out.print(evals[i][j]+" "); } System.out.println(); }
		 */

		return PM;
	}

	private Matrix computeCovarianceMatrix(double[][] m) {
		// double[][] C = new double[M.length][M.length];

		Matrix M = new Matrix(m);
		Matrix MT = M.transpose();
		Matrix C = M.times(MT);
		return C;
	}

	private double[][] centerAroundMean(double[][] M) {

		double[] mean = new double[M.length];
		for (int i = 0; i < M.length; i++)
			for (int j = 0; j < M[0].length; j++)
				mean[i] += M[i][j];
		for (int i = 0; i < M.length; i++)
			mean[i] /= M[0].length;
		for (int i = 0; i < M.length; i++)
			for (int j = 0; j < M[0].length; j++)
				M[i][j] -= mean[i];
		return M;
	}

	private double[][] projectSamples(Matrix FOld, Matrix TransformMat) {

		return (FOld.transpose().times(TransformMat)).transpose()
				.getArrayCopy();
	}

	/**
	 * Tworzymy wektor reprezenetujacy jeden obiekt. W macierzach informacje sa
	 * trzymane w postaci CECHY (wiersze) x OBIETY (kolumny), a do dalszych
	 * obliczeñ przydadz¹ siê informacje o samych obiektach, wiêc do tematu
	 * trzeba podejœæ od dupy strony.
	 * 
	 * @param index
	 *            - indeks z macierzy
	 * @param objectsMatrix
	 *            - macierz z danymi
	 */
	protected double[] extractObjectFeatures(double[][] objectsMatrix, int index) {
		double[] result = new double[FeatureCount];
		for (int i = 0; i < FeatureCount; i++) {
			result[i] = objectsMatrix[i][index];
		}
		return result;
	}

	/**
	 * Bazowa klasa klasyfikatora.
	 */
	private abstract class Classifier {
		protected List<Point> allObjects = new ArrayList<>();
		protected ArrayList<Point> classifiedObjects = new ArrayList<>();
		protected ArrayList<Point> unclassifiedObjects = new ArrayList<>();
		protected List<Point> unclassifiedObjectsCopy = new ArrayList<>();
		protected int properlyClassified = 0;

		public Classifier() {
			generateTrainingSets();
		}

		/**
		 * Metoda dzieli obiekty na sklasyfikowane i niesklasyfikowane. Wymiar
		 * macierzy obiektow sklasyfikowanych i niesklasyfikowanych 64 x X;
		 * Wiersze - cechy, kolumny - obiekty.
		 */
		private void generateTrainingSets() {
			double methodStartTime = System.currentTimeMillis();
			System.out.println("[generateTrainingSets - start]");

			int numberOfAllObjects = ClassLabels.length;
			int numberOfClassifedObjects = (int) (numberOfAllObjects
					* Integer.valueOf(tf_TrainSetSize.getText()) / 100.0);

			// Tworzymy liste ze wszystkimi obiektami
			for (int i = 0; i < ClassLabels.length; i++) {
				if (ClassLabels[i] == 0)
					allObjects.add(new Point(extractObjectFeatures(
							featuresA, i), Point.CLASS_A, i));
				else
					allObjects.add(new Point(extractObjectFeatures(
							featuresB, i - featuresA[0].length),
							Point.CLASS_B, i));
			}

			Collections.shuffle(allObjects);

			classifiedObjects.addAll(allObjects.subList(0, numberOfClassifedObjects));
			unclassifiedObjects.addAll(allObjects.subList(numberOfClassifedObjects, allObjects.size()));

			for (Point o : unclassifiedObjects) {
				try {
					unclassifiedObjectsCopy.add((Point) o.clone());
				} catch (CloneNotSupportedException e) {
					e.printStackTrace();
				}
			}
			
			for (Point o : unclassifiedObjects)
				o.setClassType(Point.UNCLASSIFIED);
			
			for (int i = 0; i < selectedFeaturesIndices.length; i++) {
				if(selectedFeaturesIndices[i] == 15)
					selectedFeaturesIndices[i] = 17;
			}
			
			double methodStopTime = System.currentTimeMillis();
			System.out.println("[generateTrainingSets - stop] Execution Time: "
					+ (methodStopTime - methodStartTime) + " miliseconds");
		}

		public void execute() {

		}
		
		protected double computeDistance(Point classified, Point unclassified) {
			double vectorLength = 0.0;
			int featureIndex = 0;
			double difference = 0.0;
			for (int i = 0; i < selectedFeaturesIndices.length; i++) {
				featureIndex = selectedFeaturesIndices[i];
				difference = classified.getFeatures()[featureIndex]
						- unclassified.getFeatures()[featureIndex];
				vectorLength += Math.pow(difference, 2);
			}
			return Math.sqrt(vectorLength);
		}
		
		protected void checkEfficiency() {
			for (int i = 0; i < unclassifiedObjects.size(); i++) {
				if (unclassifiedObjects.get(i).compareTo(
						unclassifiedObjectsCopy.get(i)) == 0)
					properlyClassified++;
			}

			String className = this.getClass().getCanonicalName();
			
			System.out.println(className.substring(className.lastIndexOf('.') + 1)
					+ " Properly classified objects: "
					+ (properlyClassified / Double.valueOf(unclassifiedObjects
							.size())) * 100 + "%");
			
			properlyClassified = 0;
		}
	}

	private class NNClassifier extends Classifier {
		protected int neighboursNumber = 1;
		protected List<Point> bestNeigbours;
		private Comparator<Point> comparator;

		public NNClassifier() {
			super();
			bestNeigbours = new ArrayList<>();
			comparator = new FileObjectComparator();
		}

		public void execute() {
			double currentDistance = 0.0;

			for (Point unclassified : unclassifiedObjects) {
				for (Point classified : classifiedObjects) {
					currentDistance = computeDistance(classified, unclassified);
					classified.setDistance(currentDistance);
					bestNeigbours.add(classified);
				}
				Collections.sort(bestNeigbours, comparator);
				assignClass(unclassified);
				bestNeigbours.clear();
			}
			
			checkEfficiency();
		}

		protected void assignClass(Point o) {
			int classACounter = 0;
			int classBCounter = 0;
			for (int i = 0; i < neighboursNumber; i++) {
				if (bestNeigbours.get(i).getClassType() == Point.CLASS_A)
					classACounter++;
				else
					classBCounter++;
			}
			if (classACounter > classBCounter)
				o.setClassType(Point.CLASS_A);
			else
				o.setClassType(Point.CLASS_B);
		}
	}

	private class KNNClassifier extends NNClassifier {
		public KNNClassifier() {
			super();
			neighboursNumber = userFeatures;
		}
			
		// Reszta zaimplementowana w klasie nadrzednej
	}

	private class NMClassifier extends Classifier {
		private Matrix selectedFeaturesA, selectedFeaturesB;
		private Matrix selectedAveragesA, selectedAveragesB;
		
		
		public NMClassifier() {
			super();
			preselectItems();
		}
		
		protected void preselectItems() {
			selectedFeaturesA = new Matrix(selectFeatures(getPointsForClass(Point.CLASS_A))); // cechy (z Fishera) x obiekty dla klasy A
			selectedFeaturesB = new Matrix(selectFeatures(getPointsForClass(Point.CLASS_B))); // cechy (z Fishera) x obiekty dla klasy B
			selectedAveragesA = cloneAverages(selectAverages(averagesA), selectedFeaturesA.getColumnDimension()); //powielone œrednie dla A  
			selectedAveragesB = cloneAverages(selectAverages(averagesB), selectedFeaturesB.getColumnDimension()); //powielone œrednie dla B
		}
		
		@Override
		public void execute() {
			Matrix covarianceMatrixA = this.computeCovarianceMatrix(selectedFeaturesA, selectedAveragesA);
			Matrix covarianceMatrixB = this.computeCovarianceMatrix(selectedFeaturesB, selectedAveragesB);
			
			for (int i = 0; i < unclassifiedObjects.size(); i++) {
				Matrix differenceVectorA = new Matrix(computeDifferenceVector(averagesA, unclassifiedObjects.get(i)), 1);
				Matrix differenceVectorB = new Matrix(computeDifferenceVector(averagesB, unclassifiedObjects.get(i)), 1);
				double mahalonobisA = mahalonobisMagic(differenceVectorA, covarianceMatrixA);
				double mahalonobisB = mahalonobisMagic(differenceVectorB, covarianceMatrixB);
				if (mahalonobisA > mahalonobisB)
					unclassifiedObjects.get(i).setClassType(Point.CLASS_B);
				else
					unclassifiedObjects.get(i).setClassType(Point.CLASS_A);
			}
			
			checkEfficiency();
		}
		
		protected List<Point> getPointsForClass(int pointClass) {
			List<Point> result = new ArrayList<>();
			for (Point p : classifiedObjects)
				if (p.getClassType() == pointClass)
					result.add(p);
			return result;
		}
		
		protected double[][] selectFeatures(List<Point> points){
			double[][] result = new double[selectedFeaturesIndices.length][points.size()];
			
			for (int i = 0; i < selectedFeaturesIndices.length; i++) {
				for (int j = 0; j < points.size(); j++) {
					result[i][j] = points.get(j).getFeatures()[selectedFeaturesIndices[i]];
				}
			}
						
			return result;
		}
		
		protected double[] selectAverages(double[] averages){
			double[] result = new double[selectedFeaturesIndices.length];
			for (int i = 0; i < selectedFeaturesIndices.length; i++) {
				int selectedFeatureIndex = selectedFeaturesIndices[i];
					result[i] = averages[selectedFeatureIndex];
			}
			return result;
		}
		
		/**
		 * 
		 * @param a macierz z cechami
		 * @param b macierz z powielonymi srednimi
		 * @return
		 */
		protected Matrix computeCovarianceMatrix(Matrix a, Matrix b) {
			Matrix result = a.minus(b);
			return result.times(result.transpose());
		}
		
		/**
		 * Wyznacza wektor wpolrzednych (cech) klasyfikowanego obiektu od sredniej 
		 */
		protected double[] computeDifferenceVector(double[] averages, Point o) {
			double[] result = new double[selectedFeaturesIndices.length];
			for (int i = 0 ; i < selectedFeaturesIndices.length; i++)
				result[i] = o.getFeatures()[selectedFeaturesIndices[i]] 
						- averages[selectedFeaturesIndices[i]];				
			return result;
		}
		
		protected double mahalonobisMagic(Matrix differenceVector, Matrix covarianceMatrix) {
			System.out.println("Mahalonobis macierz kowariancji:\n" + Arrays.deepToString(covarianceMatrix.getArray()));
			
			double result = 0.0;
			Matrix difVectorCopy = new Matrix(differenceVector.getArray());
			Matrix invertedCovariance = covarianceMatrix.inverse(); 
			result = differenceVector
					.times(invertedCovariance)
					.times(difVectorCopy.transpose())
					.getArray()[0][0]; 
			
			return Math.sqrt(result);
		}		
	}
	
	private class KNMClassifier extends NMClassifier {
	
		protected List<Point> classifiedPointsA; 
		protected List<Point> classifiedPointsB; 
		private List<Point> currentCentroidsList = new ArrayList<>();
		private List<Point> previousCentoridsList = new ArrayList<>();
		private double[] averagesForSelectedFeaturesA;
		private double[] averagesForSelectedFeaturesB;
		
		public KNMClassifier() {
			super();
			
			for (Point p : classifiedObjects)
				p.setSelectedFeatures(selectedFeaturesIndices);
			
			classifiedPointsA = getPointsForClass(Point.CLASS_A);
			classifiedPointsB = getPointsForClass(Point.CLASS_B);
			averagesForSelectedFeaturesA = computeAverageForSelectedFeatures(classifiedPointsA);
			averagesForSelectedFeaturesB = computeAverageForSelectedFeatures(classifiedPointsB);
		}
		
		/**
		 * Losuje centroidy. 
		 */
		protected void getRandomCentroids(int classType, int numberOfCentorids) {
			List<Point> points = getPointsForClass(classType);
			currentCentroidsList.clear();
			previousCentoridsList.clear();
			while(currentCentroidsList.size() != numberOfCentorids) {
				Collections.shuffle(points);
				currentCentroidsList.add(points.get(0));
				points.remove(0);
			}
		}
				
		protected double[] computeAverageForSelectedFeatures(List<Point> points) {
			double[] result = new double[selectedFeaturesIndices.length];
			for (int i = 0; i < selectedFeaturesIndices.length; i++) {
				double sum = 0.0;
				for (Point p : points)
					sum += p.getSelectedFeatures()[i]; 
				result[i] = sum / points.size();
			}
			return result;
		}
		
		@Override
		protected double[] computeDifferenceVector(double[] averages, Point o) {
			double[] result = new double[averages.length];
			for (int i = 0; i < averages.length; i++) {
				result[i] = o.getSelectedFeatures()[i] - averages[i];
			}
			return result;	
		}
		
		@Override
		public void execute() {
			currentCentroidsList = new ArrayList<>();
			previousCentoridsList = new ArrayList<>();
			List<Matrix> covarianceMatrixListA = findListOfCovarianceMatrixForClass(classifiedPointsA, Point.CLASS_A);
			
			currentCentroidsList = new ArrayList<>();
			previousCentoridsList = new ArrayList<>();
			System.out.println("Klasa B:");
			List<Matrix> covarianceMatrixListB = findListOfCovarianceMatrixForClass(classifiedPointsB, Point.CLASS_B);
						
			for (Point unclassified : unclassifiedObjects) { 
				double minA = Double.MAX_VALUE;
				double minB = Double.MAX_VALUE;
							
				unclassified.setSelectedFeatures(selectedFeaturesIndices);
				
				for (Matrix m : covarianceMatrixListA) {
					double result = mahalonobisMagic(convertVectorToMatrix(computeDifferenceVector(averagesForSelectedFeaturesA, unclassified)), m);
					if (result < minA)
						minA = result;
				}
				
				for (Matrix m : covarianceMatrixListB) {
					double result = mahalonobisMagic(convertVectorToMatrix(computeDifferenceVector(averagesForSelectedFeaturesB, unclassified)), m);
					if (result < minB)
						minB = result;
				}
				
				if (minA < minB)
					unclassified.setClassType(Point.CLASS_A);
				else
					unclassified.setClassType(Point.CLASS_B);
			}
			
			checkEfficiency();
			
			System.out.println("[KNM] Koniec.");
		}
		
	
		
		private List<Matrix> findListOfCovarianceMatrixForClass(List<Point> classifiedPoints, int classType) {
			double prevE = Double.MAX_VALUE;		// suma odleglosci dla starych centroidow
			double currentE = Double.MAX_VALUE;	// suma odleglosci dla nowych centroidow
					
			for (int numberOfCentroids = 1; numberOfCentroids < 10; numberOfCentroids++) {
				getRandomCentroids(classType, numberOfCentroids);
				while (!compareCentroids(previousCentoridsList, currentCentroidsList)) {
					prevE = currentE;
					double[][] distances = computeDistancesFromCentorids(classifiedPoints);
					assignDistrictToPoints(distances, classifiedPoints);
					checkAssigment(classifiedPoints);
					currentE = computeSumOfDistances(classifiedPoints);
					double[][] newCentroids = computeAveragesForDistrict(classifiedPoints, numberOfCentroids);
					setNewCentroids(newCentroids, classType);
					
				}
				if (currentE > prevE) {
					break;
				}
			}
			
			currentCentroidsList = previousCentoridsList;
			
			List<Matrix> covarianceMatrixListA = new ArrayList<>();
			
			for (Point p : currentCentroidsList) {
				Matrix m = createMatrixFromPointsAssignedToDistrict(classifiedPoints, p);
				
				if (m.getColumnDimension() == 0) {
					continue;
				}
								
				Matrix clonedAverages = cloneAverages(computeAveragesForMatrix(m), m.getColumnDimension());
				Matrix covariance = computeCovarianceMatrix(m, clonedAverages);
				covarianceMatrixListA.add(covariance);
			}
			
			return covarianceMatrixListA;
		}
		
		
		protected Matrix convertVectorToMatrix(double[] v) {
			double[][] matrix = new double[1][v.length];
			matrix[0] = v;
			return new Matrix(matrix);
		}
		
		/**
		 * Tworzy macierz ze wszystkich punktow przypisanych do danego obszaru (centroidu).
		 * cechy x obiekty 
		 */
		protected Matrix createMatrixFromPointsAssignedToDistrict(List<Point> points, Point centroid) {
			int numberOfObjects = 0;
			
			for (Point p : points)
				if (p.getCentroid() == centroid)
					numberOfObjects++;
			
			double[][] result = new double[selectedFeaturesIndices.length][numberOfObjects];
			for (int i = 0; i < selectedFeaturesIndices.length; i++) {
				int j = 0;
				for (Point p : points) {
					if (p.getCentroid() == centroid) {
						result[i][j++] = p.getSelectedFeatures()[i];
					}
				}
			}
			return new Matrix(result);
		}
		
		/**
		 * Liczy œredni¹ cech dla powyzej wyliczonej macierzy 
		 * 
		 */
		protected double[] computeAveragesForMatrix(Matrix matrix) {
			double[][] m = matrix.getArray();
			double[] result = new double[m.length];
			
			for (int i = 0; i < m.length; i++) {
				double sum = 0.0;
				for (int j = 0; j < m[i].length; j++) {
					sum += m[i][j];
				}
		
				result[i] = sum / m[i].length;
			}
			return result;
		}
		
		private void checkAssigment(List<Point> classified) {
			int[] d = new int[currentCentroidsList.size()];
			for (int i = 0; i < currentCentroidsList.size(); i++) {
				for (Point p : classified)
					if (p.getCentroid() == currentCentroidsList.get(i))
						d[i]++;
			}
			System.out.println("Przpisanie do centroidow: "+ Arrays.toString(d));	
		}
		
		/**
		 * Zwraca macierz z odleglosciami od wszystkich centroidow. 
		 * Wiersze - centroidy / kolumny - odleglosci dla kolejnych punktow
		 */
		protected double[][] computeDistancesFromCentorids(List<Point> points) {
			double[][] result = new double[currentCentroidsList.size()][points.size()];
					
			for (int i = 0; i < currentCentroidsList.size(); i++) {
				for (int j = 0; j< points.size();j++) { 
					double[] differenceVector = subtractVectors(
							currentCentroidsList.get(i).getSelectedFeatures(), 
							points.get(j).getSelectedFeatures());
					result[i][j] = computeVectorLength(differenceVector);
				}
			}
			
			return result;
		}
		
		/**
		 * Przydziela do ktorego obszaru nalezy punkt (do ktorego centroidu najblizej). 
		 */
		protected void assignDistrictToPoints(double[][] distancesMatrix, List<Point> points) {
			for (int j = 0; j < distancesMatrix[0].length; j++) {
				double min = Double.MAX_VALUE;
				for (int i = 0; i < distancesMatrix.length; i++) {
					if (min > distancesMatrix[i][j]) {
						min = distancesMatrix[i][j];
						points.get(j).setCentroid(currentCentroidsList.get(i));
						points.get(j).setDistance(min);
					}
				}
			}
		}
		
		/**
		 * Liczymy srednie dla wszystkich puntkow nalezacych do kolejny centroidow. 
		 * Te srednie stana sie kolejnymi centroidami. 
		 */
		protected double[][] computeAveragesForDistrict(List<Point> points, int numberOfCentroids) {
			double[][]result = new double[numberOfCentroids][];
			for (int i = 0; i < numberOfCentroids; i++) {
				double[] averages = new double[selectedFeaturesIndices.length];
				int pointsAmount = 0;	//ile punktow nalezy do danego centrodiu
				for (int j = 0; j < points.size(); j++) {
					if (points.get(j).getCentroid() == currentCentroidsList.get(i)) {
						averages = sumVectors(averages, points.get(j).getSelectedFeatures());
						pointsAmount++;
					}
				}
				for (int j = 0; j < averages.length; j++){
					if (pointsAmount != 0)
						averages[j] = averages[j] / pointsAmount;
				}
				result[i] = averages;
			}
			
			return result;
		}
		
		/**
		 * Ustawiamy nowe centroidy dla kolejnej iteracji. 
		 */
		protected void setNewCentroids(double[][] newCentroids, int classType) {
			previousCentoridsList.clear();
			previousCentoridsList.addAll(currentCentroidsList);
			currentCentroidsList.clear();
			for (int i = 0; i < newCentroids.length; i++) {
				Point p = new Point(newCentroids[0].length);
				p.setSelectedFeatures(newCentroids[i]);
				p.setFeatures(newCentroids[i]);
				p.setClassType(classType);
				currentCentroidsList.add(p);
			}
		}
		
		/**
		 * Porównanie centroidów. 
		 */
		protected boolean compareCentroids(List<Point> old, List<Point> current) {
			if(old.size() != current.size())
				return false;
			for (int i = 0; i < old.size(); i++) {
				double[] oldFeatures = old.get(i).getSelectedFeatures();
				double[] currentFeatures = current.get(i).getSelectedFeatures();
				for (int j = 0; j < oldFeatures.length; j++)
					if (oldFeatures[j] != currentFeatures[j])
						return false;
			}
			return true;
		}
		
		/**
		 * Liczymy sume odleglosci dla centroidow
		 */
		protected double computeSumOfDistances(List<Point> points) {
			double[] sumForCentroids = new double[currentCentroidsList.size()];
			double result = 0;
			for(int i = 0; i < currentCentroidsList.size(); i++) {
				for(Point p : points){
					if (p.getCentroid() == currentCentroidsList.get(i))
						sumForCentroids[i] += p.getDistance();
				}
				result += sumForCentroids[i];
			}
						
			return result;
		}
	}
}
